
/**
 *  List<?>
 *  순서대로 저장, 중복저장 허용!!!
 *  어떠한 List를 사용하건 기능은 동일하나 성능의 차이만 존재한다.
 *
 *  ArrayList : 배열 기반(확장 시 속도는 Linked 보다 느리다)
 *  LinkedList : 연결 기반
 *
 *  배열은 삭제 시 앞당기는 과정이 필요하기 때문에 작업 시간이 증가한다.
 *  링크드 방식은 연결 주소지만 옮기면 되기 때문에
 *  자료구조 내에서 삭제 작업이 배열보다 유리하다.
 *
 *  배열의 장점 : 저장된 인스턴스의 참조가 빠르다(인덱스 기준이기 때문에)
 *  배열의 단점 : 저장 공간을 늘리는 과정에서 시간이 엄청 소요된다.
 *             인스턴스의 삭제 과정에서 많은 연산이 필요하다.
 *
 *  링크드 장점 : 저장 공간을 늘리는 과정이 간단하다.(연결 주소지만 옮겨주면 되기 때문)
 *             저장 인스턴스의 삭제 과정이 단순하다.(연결 주소지만 옮겨주면 되기 때문)
 *  링크드 단점 : 저장된 인스턴스의 참조 과정이 배열에 비해 복잡하다. > 느리다
 *             인덱스 기준이 아닌 연결 '첫 주소지' 기준으로 부터 주소지를 쫓아가기 때문에
 * */


/**
 *  Set<?> : 집합의 특성
 *  중복을 허용하지 않는다. 순서 보장이 되지 않는다.
 *  동일 인스턴스의 중복 저장이 안된다.
 *  동일 인스턴스의 기준은 ??
 *  Object class의 equals 메소드 호출 결과를 근거로 동일 인스턴스를 판단한다.
 *  그런데 그에 앞서 Object class의 hashcode 메소드 호출 결과가 같아야 한다.
 *
 *  Hash Algorithm 원리
 *  만약 1, 2, 3, 4, 5, 6 이라는 Set 데이터가 있고
 *  7이라는 값이 추가된다고 가정했을 때
 *  Set안에 7이 있는지 비교하려면 1~6까지 6번 비교를 해야한다.
 *
 *  그러면 비효율적이기 때문에 1~6까지 데이터를 세분화해서 분류를 하는 것이 해쉬 알고리즘
 *  분류 기준(알고리즘)을 num%3으로 소분한다면 0,1,2
 *  소분된 0, 1, 2 에 1~6까지의 결과값을 소분하여 저장하고
 *  새로 추가되는 데이터는 7%3 = 2 이므로
 *  2로 소분된 집합 내의 데이터만 비교하면 된다.
 *  이것이 해쉬 알고리즘의 기본!!!!
 *  
 * */