package Level1JavaFile;
//개인정보 수집 유효기간
//문제 설명
//고객의 약관 동의를 얻어서 수집된 1~n번으로 분류되는 개인정보 n개가 있습니다. 약관 종류는 여러 가지 있으며 각 약관마다 개인정보 보관 유효기간이 정해져 있습니다. 당신은 각 개인정보가 어떤 약관으로 수집됐는지 알고 있습니다. 수집된 개인정보는 유효기간 전까지만 보관 가능하며, 유효기간이 지났다면 반드시 파기해야 합니다.
//
//예를 들어, A라는 약관의 유효기간이 12 달이고, 2021년 1월 5일에 수집된 개인정보가 A약관으로 수집되었다면 해당 개인정보는 2022년 1월 4일까지 보관 가능하며 2022년 1월 5일부터 파기해야 할 개인정보입니다.
//당신은 오늘 날짜로 파기해야 할 개인정보 번호들을 구하려 합니다.
//
//모든 달은 28일까지 있다고 가정합니다.
//
//다음은 오늘 날짜가 2022.05.19일 때의 예시입니다.
//
//약관 종류	유효기간
//A	6 달
//B	12 달
//C	3 달
//번호	개인정보 수집 일자	약관 종류
//1	2021.05.02	A
//2	2021.07.01	B
//3	2022.02.19	C
//4	2022.02.20	C
//첫 번째 개인정보는 A약관에 의해 2021년 11월 1일까지 보관 가능하며, 유효기간이 지났으므로 파기해야 할 개인정보입니다.
//두 번째 개인정보는 B약관에 의해 2022년 6월 28일까지 보관 가능하며, 유효기간이 지나지 않았으므로 아직 보관 가능합니다.
//세 번째 개인정보는 C약관에 의해 2022년 5월 18일까지 보관 가능하며, 유효기간이 지났으므로 파기해야 할 개인정보입니다.
//네 번째 개인정보는 C약관에 의해 2022년 5월 19일까지 보관 가능하며, 유효기간이 지나지 않았으므로 아직 보관 가능합니다.
//따라서 파기해야 할 개인정보 번호는 [1, 3]입니다.
//
//오늘 날짜를 의미하는 문자열 today, 약관의 유효기간을 담은 1차원 문자열 배열 terms와 수집된 개인정보의 정보를 담은 1차원 문자열 배열 privacies가 매개변수로 주어집니다. 이때 파기해야 할 개인정보의 번호를 오름차순으로 1차원 정수 배열에 담아 return 하도록 solution 함수를 완성해 주세요.
//
//제한사항
//today는 "YYYY.MM.DD" 형태로 오늘 날짜를 나타냅니다.
//1 ≤ terms의 길이 ≤ 20
//terms의 원소는 "약관 종류 유효기간" 형태의 약관 종류와 유효기간을 공백 하나로 구분한 문자열입니다.
//약관 종류는 A~Z중 알파벳 대문자 하나이며, terms 배열에서 약관 종류는 중복되지 않습니다.
//유효기간은 개인정보를 보관할 수 있는 달 수를 나타내는 정수이며, 1 이상 100 이하입니다.
//1 ≤ privacies의 길이 ≤ 100
//privacies[i]는 i+1번 개인정보의 수집 일자와 약관 종류를 나타냅니다.
//privacies의 원소는 "날짜 약관 종류" 형태의 날짜와 약관 종류를 공백 하나로 구분한 문자열입니다.
//날짜는 "YYYY.MM.DD" 형태의 개인정보가 수집된 날짜를 나타내며, today 이전의 날짜만 주어집니다.
//privacies의 약관 종류는 항상 terms에 나타난 약관 종류만 주어집니다.
//today와 privacies에 등장하는 날짜의 YYYY는 연도, MM은 월, DD는 일을 나타내며 점(.) 하나로 구분되어 있습니다.
//2000 ≤ YYYY ≤ 2022
//1 ≤ MM ≤ 12
//MM이 한 자릿수인 경우 앞에 0이 붙습니다.
//1 ≤ DD ≤ 28
//DD가 한 자릿수인 경우 앞에 0이 붙습니다.
//파기해야 할 개인정보가 하나 이상 존재하는 입력만 주어집니다.
//입출력 예
//today	terms	privacies	result
//"2022.05.19"	["A 6", "B 12", "C 3"]	["2021.05.02 A", "2021.07.01 B", "2022.02.19 C", "2022.02.20 C"]	[1, 3]
//"2020.01.01"	["Z 3", "D 5"]	["2019.01.01 D", "2019.11.15 Z", "2019.08.02 D", "2019.07.01 D", "2018.12.28 Z"]	[1, 4, 5]
//입출력 예 설명
//입출력 예 #1
//
//문제 예시와 같습니다.
//입출력 예 #2
//
//약관 종류	유효기간
//Z	3 달
//D	5 달
//번호	개인정보 수집 일자	약관 종류
//1	2019.01.01	D
//2	2019.11.15	Z
//3	2019.08.02	D
//4	2019.07.01	D
//5	2018.12.28	Z
//오늘 날짜는 2020년 1월 1일입니다.
//
//첫 번째 개인정보는 D약관에 의해 2019년 5월 28일까지 보관 가능하며, 유효기간이 지났으므로 파기해야 할 개인정보입니다.
//두 번째 개인정보는 Z약관에 의해 2020년 2월 14일까지 보관 가능하며, 유효기간이 지나지 않았으므로 아직 보관 가능합니다.
//세 번째 개인정보는 D약관에 의해 2020년 1월 1일까지 보관 가능하며, 유효기간이 지나지 않았으므로 아직 보관 가능합니다.
//네 번째 개인정보는 D약관에 의해 2019년 11월 28일까지 보관 가능하며, 유효기간이 지났으므로 파기해야 할 개인정보입니다.
//다섯 번째 개인정보는 Z약관에 의해 2019년 3월 27일까지 보관 가능하며, 유효기간이 지났으므로 파기해야 할 개인정보입니다.

import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;


//신고 결과 받기
//문제 설명
//문제 설명
//신입사원 무지는 게시판 불량 이용자를 신고하고 처리 결과를 메일로 발송하는 시스템을 개발하려 합니다. 무지가 개발하려는 시스템은 다음과 같습니다.
//
//각 유저는 한 번에 한 명의 유저를 신고할 수 있습니다.
//신고 횟수에 제한은 없습니다. 서로 다른 유저를 계속해서 신고할 수 있습니다.
//한 유저를 여러 번 신고할 수도 있지만, 동일한 유저에 대한 신고 횟수는 1회로 처리됩니다.
//k번 이상 신고된 유저는 게시판 이용이 정지되며, 해당 유저를 신고한 모든 유저에게 정지 사실을 메일로 발송합니다.
//유저가 신고한 모든 내용을 취합하여 마지막에 한꺼번에 게시판 이용 정지를 시키면서 정지 메일을 발송합니다.
//다음은 전체 유저 목록이 ["muzi", "frodo", "apeach", "neo"]이고, k = 2(즉, 2번 이상 신고당하면 이용 정지)인 경우의 예시입니다.
//
//유저 ID	유저가 신고한 ID	설명
//"muzi"	"frodo"	"muzi"가 "frodo"를 신고했습니다.
//"apeach"	"frodo"	"apeach"가 "frodo"를 신고했습니다.
//"frodo"	"neo"	"frodo"가 "neo"를 신고했습니다.
//"muzi"	"neo"	"muzi"가 "neo"를 신고했습니다.
//"apeach"	"muzi"	"apeach"가 "muzi"를 신고했습니다.
//각 유저별로 신고당한 횟수는 다음과 같습니다.
//
//유저 ID	신고당한 횟수
//"muzi"	1
//"frodo"	2
//"apeach"	0
//"neo"	2
//위 예시에서는 2번 이상 신고당한 "frodo"와 "neo"의 게시판 이용이 정지됩니다. 이때, 각 유저별로 신고한 아이디와 정지된 아이디를 정리하면 다음과 같습니다.
//
//유저 ID	유저가 신고한 ID	정지된 ID
//"muzi"	["frodo", "neo"]	["frodo", "neo"]
//"frodo"	["neo"]	["neo"]
//"apeach"	["muzi", "frodo"]	["frodo"]
//"neo"	없음	없음
//따라서 "muzi"는 처리 결과 메일을 2회, "frodo"와 "apeach"는 각각 처리 결과 메일을 1회 받게 됩니다.
//
//이용자의 ID가 담긴 문자열 배열 id_list, 각 이용자가 신고한 이용자의 ID 정보가 담긴 문자열 배열 report, 정지 기준이 되는 신고 횟수 k가 매개변수로 주어질 때, 각 유저별로 처리 결과 메일을 받은 횟수를 배열에 담아 return 하도록 solution 함수를 완성해주세요.
//
//제한사항
//2 ≤ id_list의 길이 ≤ 1,000
//1 ≤ id_list의 원소 길이 ≤ 10
//id_list의 원소는 이용자의 id를 나타내는 문자열이며 알파벳 소문자로만 이루어져 있습니다.
//id_list에는 같은 아이디가 중복해서 들어있지 않습니다.
//1 ≤ report의 길이 ≤ 200,000
//3 ≤ report의 원소 길이 ≤ 21
//report의 원소는 "이용자id 신고한id"형태의 문자열입니다.
//예를 들어 "muzi frodo"의 경우 "muzi"가 "frodo"를 신고했다는 의미입니다.
//id는 알파벳 소문자로만 이루어져 있습니다.
//이용자id와 신고한id는 공백(스페이스)하나로 구분되어 있습니다.
//자기 자신을 신고하는 경우는 없습니다.
//1 ≤ k ≤ 200, k는 자연수입니다.
//return 하는 배열은 id_list에 담긴 id 순서대로 각 유저가 받은 결과 메일 수를 담으면 됩니다.
//입출력 예
//id_list	report	k	result
//["muzi", "frodo", "apeach", "neo"]	["muzi frodo","apeach frodo","frodo neo","muzi neo","apeach muzi"]	2	[2,1,1,0]
//["con", "ryan"]	["ryan con", "ryan con", "ryan con", "ryan con"]	3	[0,0]
//입출력 예 설명
//입출력 예 #1
//
//문제의 예시와 같습니다.
//
//입출력 예 #2
//
//"ryan"이 "con"을 4번 신고했으나, 주어진 조건에 따라 한 유저가 같은 유저를 여러 번 신고한 경우는 신고 횟수 1회로 처리합니다. 따라서 "con"은 1회 신고당했습니다. 3번 이상 신고당한 이용자는 없으며, "con"과 "ryan"은 결과 메일을 받지 않습니다. 따라서 [0, 0]을 return 합니다.
//
//제한시간 안내
//정확성 테스트 : 10초


class Solution_3 {
    public int[] solution(String[] id_list, String[] report, int k) {
        int[] answer = new int[id_list.length];
        
        // 신고자 별 받는 메일 개수 담는 
        LinkedHashMap<String, Integer> result = new LinkedHashMap<>();
        for(String s : id_list) {
        	result.put(s,  0);
        }
        
        //개인별 신고자 id를 담고 있는 Set
        Map<String, Set<String>> map = new LinkedHashMap<>();

	    for(int i = 0 ; i < id_list.length ; i++) {
	    	map.put(id_list[i], new LinkedHashSet<>());
	    }
        
        for(int i = 0 ; i < report.length ; i++) {
        	String[] arr = report[i].split(" ");
        	Set<String> newSet = map.get(arr[1]);
        	
        	if(!newSet.contains(arr[0])) {
        		newSet.add(arr[0]);
        	}
        	map.put(arr[1], newSet);
        }
        
        for(int i = 0 ; i < map.size() ; i++) {
        	Set<String> s = map.get(id_list[i]);
        	if(s.size() >= k) {
        		Iterator<String> iter = s.iterator();
        		while(iter.hasNext()) {
        			String key = iter.next();
        			result.put(key, result.getOrDefault(key, 0)+1);
        		}
        	}
        }
        
        int idx = 0;
        for(Entry<String, Integer> e : result.entrySet()) {
        	answer[idx++] = e.getValue();
        }
        return answer;
    }
}

